<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SKRTEK System Benchmark</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background: #111; color: white; }
        button { padding: 12px 24px; font-size: 18px; background: #ff5722; color: white; border: none; border-radius: 4px; cursor: pointer; margin: 10px; }
        button:hover { background: #e64a19; }
        #progress-container { width: 80%; margin: 20px auto; background: #333; border-radius: 4px; }
        #progress-bar { height: 20px; background: #4CAF50; border-radius: 4px; width: 0%; transition: width 0.3s; }
        #3d-container { width: 800px; height: 600px; margin: 20px auto; border: 2px solid #444; }
        #results { margin: 20px; font-size: 18px; min-height: 100px; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto; }
        .grade { font-size: 32px; font-weight: bold; margin: 20px; padding: 15px; border-radius: 8px; }
        .A { background: #4CAF50; } .B { background: #8BC34A; } .C { background: #FFC107; }
        .D { background: #FF9800; } .F { background: #F44336; }
        #status { margin: 10px; color: #ff9800; }
        .test-result { margin: 15px 0; padding: 10px; background: #222; border-radius: 5px; }
        .test-title { font-weight: bold; color: #ff9800; }
        .test-metrics { display: flex; justify-content: space-between; margin-top: 5px; }
        .final-score { font-size: 24px; margin: 20px 0; }
        #system-info { margin: 20px; padding: 15px; background: #222; border-radius: 5px; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto; }
        .worker-status { color: #4CAF50; font-weight: bold; }
    </style>
</head>
<body>
    <h1>SKRTEK SYSTEM BENCHMARK</h1>
    <p>Extreme CPU/GPU Stress Test - Will Push Your System to 100%</p>
    
    <button id="run">BEGIN EXTREME TEST</button>
    <div id="status">Ready to begin...</div>
    <div id="progress-container"><div id="progress-bar"></div></div>
    
    <div id="3d-container"></div>
    <div id="system-info"></div>
    <div id="worker-status" class="worker-status"></div>
    <div id="results"></div>
    <div id="grade" class="grade" style="display: none;"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ===== Extreme Configuration =====
        const CPU_TEST_DURATION = 15000; // 15 seconds of brutal CPU work
        const GPU_TEST_DURATION = 15000; // 15 seconds of intense GPU work
        const THREEJS_PARTICLES = 150000; // 150K particles for serious GPU stress
        const CPU_WORKERS = 8; // Number of parallel CPU workers
        const MATH_COMPLEXITY = 5000000; // Extreme math operations

        // ===== DOM Elements =====
        const runButton = document.getElementById("run");
        const progressBar = document.getElementById("progress-bar");
        const container3D = document.getElementById("3d-container");
        const resultsDiv = document.getElementById("results");
        const gradeDiv = document.getElementById("grade");
        const statusEl = document.getElementById("status");
        const systemInfoEl = document.getElementById("system-info");
        const workerStatusEl = document.getElementById("worker-status");

        // ===== Benchmark State =====
        let benchmarkRunning = false;
        let testResults = {
            cpu: { score: 0, time: 0, operations: 0, workers: 0 },
            gpu: { score: 0, time: 0, fps: 0 },
            memory: { score: 0, time: 0, operations: 0 }
        };
        let activeWorkers = 0;

        // Detect system info
        function detectSystemInfo() {
            const cores = navigator.hardwareConcurrency || 'Unknown';
            testResults.cpu.workers = Math.min(CPU_WORKERS, cores);
            
            let info = "<div class='test-title'>System Information</div>";
            info += `<div>CPU Cores: ${cores} (Using ${testResults.cpu.workers} workers)</div>`;
            info += `<div>User Agent: ${navigator.userAgent}</div>`;
            info += `<div>WebGL: ${detectWebGL() ? 'Supported' : 'Not Supported'}</div>`;
            systemInfoEl.innerHTML = info;
        }

        function detectWebGL() {
            try {
                const canvas = document.createElement('canvas');
                return !!window.WebGLRenderingContext && 
                    (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
            } catch(e) {
                return false;
            }
        }

        function updateStatus(message) {
            statusEl.textContent = message;
            console.log(message);
        }

        // ===== Main Benchmark =====
        runButton.addEventListener("click", async () => {
            if (benchmarkRunning) return;
            
            try {
                // Initialize benchmark
                benchmarkRunning = true;
                runButton.disabled = true;
                resultsDiv.innerHTML = "";
                gradeDiv.style.display = "none";
                testResults = {
                    cpu: { score: 0, time: 0, operations: 0, workers: 0 },
                    gpu: { score: 0, time: 0, fps: 0 },
                    memory: { score: 0, time: 0, operations: 0 }
                };
                
                // Reset UI
                container3D.innerHTML = "";
                progressBar.style.width = "0%";
                
                detectSystemInfo();
                
                // Phase 1: Extreme CPU Stress Test
                updateStatus("Running EXTREME CPU stress test...");
                await runCPUTest();
                
                // Phase 2: Brutal GPU Stress Test
                updateStatus("Running BRUTAL GPU stress test...");
                await runGPUTest();
                
                // Calculate final score
                const totalScore = Math.round(
                    testResults.cpu.score * 0.6 + 
                    testResults.gpu.score * 0.4
                );
                
                // Show final results
                showDetailedResults(totalScore);
                updateStatus("Benchmark complete - System pushed to limits!");
            } catch (error) {
                console.error("Benchmark error:", error);
                resultsDiv.innerHTML += `<div style="color:red">Error: ${error.message}</div>`;
                updateStatus("Benchmark failed - see console for details");
            } finally {
                benchmarkRunning = false;
                runButton.disabled = false;
            }
        });

        // ===== Extreme CPU Stress Test =====
        async function runCPUTest() {
            const startTime = performance.now();
            let totalOperations = 0;
            let completedWorkers = 0;
            
            // Create Web Workers for true multi-core stress
            const workerCount = testResults.cpu.workers;
            activeWorkers = workerCount;
            workerStatusEl.textContent = `Running ${workerCount} CPU workers at 100%...`;
            
            for (let i = 0; i < workerCount; i++) {
                const worker = new Worker(URL.createObjectURL(new Blob([`
                    let operations = 0;
                    const start = Date.now();
                    
                    // Extreme math operations
                    function crunchNumbers() {
                        for (let i = 0; i < ${MATH_COMPLEXITY}; i++) {
                            operations++;
                            // Insanely complex math
                            const val = Math.sqrt(Math.pow(Math.sin(i) * Math.cos(i*0.3), 2)) + 
                                       Math.log(Math.abs(i) + 1) * Math.random();
                            if (i % 100000 === 0) self.postMessage({ type: 'progress', ops: operations });
                        }
                        return operations;
                    }
                    
                    // Run until main thread tells us to stop
                    self.onmessage = (e) => {
                        if (e.data === 'stop') {
                            self.postMessage({ type: 'result', ops: operations });
                            self.close();
                        }
                    };
                    
                    // Initial run
                    crunchNumbers();
                    
                    // Keep CPU at 100%
                    function keepWorking() {
                        operations += crunchNumbers();
                        setTimeout(keepWorking, 0);
                    }
                    
                    keepWorking();
                `], { type: 'application/javascript' })));
                
                worker.onmessage = (e) => {
                    if (e.data.type === 'progress') {
                        totalOperations += e.data.ops;
                        updateCpuProgress(startTime, totalOperations);
                    } else if (e.data.type === 'result') {
                        totalOperations += e.data.ops;
                        completedWorkers++;
                        if (completedWorkers === workerCount) {
                            finishCPUTest(startTime, totalOperations);
                        }
                    }
                };
                
                // Stop worker after test duration
                setTimeout(() => worker.postMessage('stop'), CPU_TEST_DURATION);
            }
            
            // Wait for all workers to complete
            await new Promise(resolve => {
                const checkComplete = setInterval(() => {
                    if (completedWorkers === workerCount) {
                        clearInterval(checkComplete);
                        resolve();
                    }
                }, 100);
            });
        }

        function updateCpuProgress(startTime, operations) {
            const elapsed = performance.now() - startTime;
            const progress = (elapsed / CPU_TEST_DURATION) * 50;
            progressBar.style.width = `${progress}%`;
            
            // Update status with estimated operations per second
            const opsPerSec = Math.round((operations / elapsed) * 1000);
            workerStatusEl.textContent = 
                `CPU Workers: ${activeWorkers} @ 100% | ${opsPerSec.toLocaleString()} ops/sec`;
        }

        function finishCPUTest(startTime, operations) {
            const time = performance.now() - startTime;
            testResults.cpu.time = time;
            testResults.cpu.operations = operations;
            testResults.cpu.score = Math.round((operations / time) * 100);
            workerStatusEl.textContent = "CPU Test Complete";
        }

        // ===== Brutal GPU Stress Test =====
        function runGPUTest() {
            return new Promise((resolve) => {
                updateStatus("Initializing BRUTAL GPU test...");
                
                // Set up Three.js scene
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, 800/600, 0.1, 5000);
                const renderer = new THREE.WebGLRenderer({ 
                    antialias: false,
                    powerPreference: "high-performance"
                });
                
                try {
                    renderer.setSize(800, 600);
                    container3D.appendChild(renderer.domElement);
                    
                    // Create massive particle system
                    const particles = new THREE.BufferGeometry();
                    const positions = new Float32Array(THREEJS_PARTICLES * 3);
                    const colors = new Float32Array(THREEJS_PARTICLES * 3);
                    const sizes = new Float32Array(THREEJS_PARTICLES);
                    
                    // Fill with random data
                    for (let i = 0; i < THREEJS_PARTICLES; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 2000;
                        positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
                        
                        colors[i * 3] = Math.random();
                        colors[i * 3 + 1] = Math.random();
                        colors[i * 3 + 2] = Math.random();
                        
                        sizes[i] = Math.random() * 3 + 1;
                    }
                    
                    particles.setAttribute("position", new THREE.BufferAttribute(positions, 3));
                    particles.setAttribute("color", new THREE.BufferAttribute(colors, 3));
                    particles.setAttribute("size", new THREE.BufferAttribute(sizes, 1));
                    
                    // Complex particle material
                    const particleMaterial = new THREE.PointsMaterial({
                        size: 2,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.9,
                        sizeAttenuation: true,
                        alphaTest: 0.1
                    });
                    
                    const particleSystem = new THREE.Points(particles, particleMaterial);
                    scene.add(particleSystem);
                    
                    // Add lighting for extra GPU load
                    const light1 = new THREE.DirectionalLight(0xffffff, 1);
                    light1.position.set(1, 1, 1).normalize();
                    scene.add(light1);
                    
                    const light2 = new THREE.AmbientLight(0x404040);
                    scene.add(light2);
                    
                    camera.position.z = 1000;
                    
                    // Animation loop
                    let frames = 0;
                    const startTime = performance.now();
                    let lastFpsUpdate = startTime;
                    let fps = 0;
                    
                    function animate() {
                        if (!benchmarkRunning || performance.now() - startTime > GPU_TEST_DURATION) {
                            const time = performance.now() - startTime;
                            testResults.gpu.time = time;
                            testResults.gpu.fps = Math.round((frames * 1000) / time);
                            testResults.gpu.score = Math.round((frames * 1000) / time * 20);
                            container3D.innerHTML = "";
                            resolve();
                            return;
                        }
                        
                        requestAnimationFrame(animate);
                        
                        // Intensive particle animation
                        const positions = particleSystem.geometry.attributes.position.array;
                        const time = performance.now() / 1000;
                        
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i] += Math.sin(time * 2 + i * 0.01) * 2;
                            positions[i+1] += Math.cos(time * 1.5 + i * 0.01) * 2;
                            positions[i+2] += Math.sin(time * 0.5 + i * 0.005) * 1;
                        }
                        
                        particleSystem.geometry.attributes.position.needsUpdate = true;
                        particleSystem.rotation.x += 0.02;
                        particleSystem.rotation.y += 0.01;
                        
                        frames++;
                        
                        // Update FPS counter
                        if (performance.now() - lastFpsUpdate > 500) {
                            fps = Math.round((frames * 1000) / (performance.now() - startTime));
                            updateStatus(`GPU Stress Test: ${fps} FPS (${THREEJS_PARTICLES.toLocaleString()} particles)`);
                            lastFpsUpdate = performance.now();
                        }
                        
                        // Update progress
                        const elapsed = performance.now() - startTime;
                        const progress = 50 + (elapsed / GPU_TEST_DURATION) * 50;
                        progressBar.style.width = `${progress}%`;
                        
                        renderer.render(scene, camera);
                    }
                    
                    animate();
                } catch (error) {
                    console.error("GPU Test Error:", error);
                    container3D.innerHTML = `<div style="color:red">GPU Test Failed: ${error.message}</div>`;
                    testResults.gpu.score = 100;
                    resolve();
                }
            });
        }

        // ===== Results Display =====
        function showDetailedResults(totalScore) {
            resultsDiv.innerHTML = `
                <div class="test-result">
                    <div class="test-title">EXTREME CPU PERFORMANCE</div>
                    <div>Parallel math crunching across ${testResults.cpu.workers} workers</div>
                    <div class="test-metrics">
                        <span>Operations: ${testResults.cpu.operations.toLocaleString()}</span>
                        <span>Time: ${(testResults.cpu.time/1000).toFixed(2)}s</span>
                        <span>Score: ${testResults.cpu.score}</span>
                    </div>
                    <div>${Math.round((testResults.cpu.operations / testResults.cpu.time) * 1000).toLocaleString()} ops/sec</div>
                </div>
                
                <div class="test-result">
                    <div class="test-title">BRUTAL GPU PERFORMANCE</div>
                    <div>3D particle rendering (${THREEJS_PARTICLES.toLocaleString()} particles)</div>
                    <div class="test-metrics">
                        <span>FPS: ${testResults.gpu.fps}</span>
                        <span>Time: ${(testResults.gpu.time/1000).toFixed(2)}s</span>
                        <span>Score: ${testResults.gpu.score}</span>
                    </div>
                </div>
                
                <div class="final-score">TOTAL SCORE: ${totalScore}</div>
            `;
            
            // Show final grade
            let grade, comment;
            if (totalScore > 12000) {
                grade = "A"; comment = "BEAST MODE! Elite Performance";
            } else if (totalScore > 9000) {
                grade = "B"; comment = "Great for Gaming/Production";
            } else if (totalScore > 6000) {
                grade = "C"; comment = "Average System";
            } else if (totalScore > 3000) {
                grade = "D"; comment = "Below Average";
            } else {
                grade = "F"; comment = "Seriously Needs Upgrade!";
            }
            
            gradeDiv.style.display = "block";
            gradeDiv.className = `grade ${grade}`;
            gradeDiv.innerHTML = `
                FINAL GRADE: ${grade}<br>
                <small>${comment}</small>
            `;
            
            progressBar.style.width = "100%";
            workerStatusEl.textContent = "All tests complete";
        }
    </script>
</body>
</html>